var e={d:(t,s)=>{for(var o in s)e.o(s,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:s[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{UE:()=>m,fV:()=>v,ft:()=>b,ni:()=>w,_I:()=>A,ZP:()=>l});const s=class{#e;#t=[];constructor(e){this.#e=e,Object.values(e.axes).forEach((e=>{this[e.name]=this.#s(e.name),e.alias&&(this[e.alias]=this.#s(e.alias))}))}execute(){return this.#e.move(...this.#t)}#s(e){return(...t)=>{if(3===t.length&&"number"==typeof t[0]&&"number"==typeof t[1]&&"function"==typeof t[2])this.#t.push({axis:e,to:t[0],speed:t[1],value:t[2]});else if(2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,to:t[0],speed:t[1]});else if(2===t.length&&"number"==typeof t[0]&&"function"==typeof t[1])this.#t.push({axis:e,to:t[0],value:t[1]});else if(1===t.length&&"number"==typeof t[0])this.#t.push({axis:e,to:t[0]});else if(2===t.length&&"function"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,value:t[0],duration:t[1]});else if(1===t.length&&"function"==typeof t[0])this.#t.push({axis:e,value:t[0]});else{if(1!==t.length||"object"!=typeof t[0])throw new Error(`Invalid arguments: ${t}`);this.#t.push({...t[0],axis:e})}return this}}};function o(e,t=0){const s=10**t;return Math.round(s*e)/s}function a(e,t,s){return Math.max(t,Math.min(s,e))}function i(e,t,s){return!(!Number.isFinite(e)||void 0!==t&&e<t||void 0!==s&&e>s)}function r(e,t,s){Object.defineProperty(e,t,{value:s,writeable:!1,configurable:!1,enumerable:!0})}function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function c(e){throw new Error(e)}const h={validateMovements(e,t,s){const o={};let a=!1,i=!1;e&&e.length||c("Must supply at least one movement."),e.forEach((e=>{e&&"object"==typeof e||c(`Invalid movement: ${e}`);const r=t=>c(`Invalid value for parameter '${t}': ${e[t]}`),h=n(e,"to"),u=n(e,"speed"),p=n(e,"duration"),l=n(e,"value"),m=e.axis||s;if(m||c("No default axis configured. Must specify an axis for each movement."),n(e,"axis")&&("string"==typeof e.axis&&e.axis.trim()&&t[e.axis]||r("axis")),h){let s=!1;s="boolean"===t[m].type?"boolean"!=typeof e.to:!Number.isFinite(e.to)||e.to<0||e.to>1,s&&r("to")}else l||c("Must provide a 'to' property or 'value' function.");u&&p&&c("Cannot supply both speed and duration."),(u||p)&&(a=!0,u&&(!Number.isFinite(e.speed)||e.speed<=0)?r("speed"):p&&(!Number.isFinite(e.duration)||e.duration<=0)&&r("duration")),u&&!h&&c("Must provide a target position when specifying speed."),l&&"function"!=typeof e.value&&c("'value' must be a function."),n(e,"sync")&&("string"==typeof e.sync&&e.sync.trim()||r("sync"),(n(e,"speed")||n(e,"duration"))&&c(`Cannot specify a speed or duration when sync property is present: ${e.axis}`)),"boolean"!==t[m].type?i=!0:(n(e,"speed")&&c(`Cannot specify speed for boolean axes: ${m}`),n(e,"duration")&&h&&!l&&c("Cannot specify a duration for a boolean axis movement with constant value.")),o[m]&&c(`Duplicate axis movement: ${m}`),o[m]=e,t[m].alias&&(o[t[m].alias]=e)})),e.forEach((e=>{let t=e;const s=e.axis;for(;n(t,"sync");)o[t.sync]||c(`Cannot sync with axis not specified in movement: ${t.axis} -> ${t.sync}`),t=o[t.sync],t.sync===s&&c("Sync axes cannot form a cycle.")})),!a&&i&&c("At least one movement must have a speed or duration.")},validateAxisConfig(e){e&&"object"==typeof e||c(`Invalid configuration object: ${e}`);const t={name:"string",type:"string",alias:"string",max:"number",min:"number"},s=["name","type"].filter((t=>void 0===e[t]||null===e[t])).sort();s.length&&c(`Configuration is missing properties: ${s.join(", ")}`);const o=[];Object.keys(t).forEach((s=>{const a=e[s];null!=a&&(typeof a!==t[s]?o.push(s):"min"!==s&&"max"!==s||(!Number.isFinite(a)||a<0||a>1)&&o.push(s))}));let{defaultValue:a}=e;null!=a?"boolean"===e.type?"boolean"!=typeof a&&o.push("defaultValue"):(!Number.isFinite(a)||a<0||a>1)&&o.push("defaultValue"):a="boolean"!==e.type&&("auxiliary"===e.type?0:.5),o.length&&c(`Invalid configuration parameter(s): ${o.sort().map((t=>`${t} = ${e[t]}`)).join(", ")}`),-1===["linear","rotation","auxiliary","boolean"].indexOf(e.type)&&c(`Invalid type. Must be linear, rotation, auxiliary, or boolean: ${e.type}`);const i={...e,defaultValue:a,max:e.max||1,min:e.min||0,value:a,lastValue:a};return(i.max===i.min||i.min>i.max)&&c(`Invalid configuration parameter(s): max = ${i.max}, min = ${i.min}`),i},validateTempestParameters(e,t,s,o,a,r){if(!(i(e,0,1)&&i(t,0,1)&&i(s)&&i(o)&&i(a)&&a>0&&i(r)))throw new Error(`One or more stroke parameters are invalid (${e}, ${t}, ${s}, ${o}, ${a}, ${r})`)}},u={name:"SR6",defaultAxis:"L0",axes:[{name:"L0",type:"linear",alias:"stroke"},{name:"L1",type:"linear",alias:"forward"},{name:"L2",type:"linear",alias:"left"},{name:"R0",type:"rotation",alias:"twist"},{name:"R1",type:"rotation",alias:"roll"},{name:"R2",type:"rotation",alias:"pitch"},{name:"A0",alias:"valve",type:"auxiliary"},{name:"A1",alias:"suck",type:"auxiliary"},{name:"A2",alias:"lube",type:"auxiliary",resetOnStop:!0},{name:"V0",alias:"vibe0",type:"auxiliary",resetOnStop:!0},{name:"V1",alias:"vibe1",type:"auxiliary",resetOnStop:!0}]};class p{#o=[];#a={};#i=50;#r=new Set;#n=1;#c=1;#h=null;#u=!1;#p;#l=new Set;defaultRamp=p.RAMP_COS;static get precision(){return 10}get performing(){return this.#u}get axes(){const e={};return Object.keys(this.#a).forEach((t=>{e[t]=this.getAxis(t)})),e}get frequency(){return this.#i}get period(){return this.#m}get#m(){return 1/this.#i}constructor(e){r(this,"$",{}),e&&this.#f(e),"undefined"==typeof Worker?this.#p={sleep:e=>new Promise((t=>{setTimeout(t,1e3*e)})),now:()=>performance.now()/1e3}:this.#p=new class{#d;#v={};#x=1;constructor(){this.#d=new Worker(this.#g((function(){onmessage=function(e){const{id:t,delay:s}=e.data;setTimeout((()=>{postMessage(t)}),1e3*s)}}))),this.#d.onmessage=({data:e})=>{const t=e;this.#v[t](),delete this.#v[t]}}sleep(e){return new Promise((t=>{const s=this.#x++;this.#v[s]=t,this.#d.postMessage({id:s,delay:e})}))}now(){return performance.now()/1e3}#g(e){const t=new Blob([`(${e.toString()})()`],{type:"text/javascript"});return URL.createObjectURL(t)}}}defaultConfiguration(){return this.#f(u),this}getTimer(){return this.#p}async do(e){this.stop();const t=this.#c++;for(this.#h=t;this.#u;)await this.sleep();for(this.#u=!0;this.#h===t&&!e.complete;)try{await e.perform(this)}catch(e){console.error(`Error performing behavior: ${e}`);break}return this.#u=!1,this.#h===t&&(this.#h=null,!0)}async move(...e){if(!this.#o||!this.#o.length)throw new Error("No output devices have been added.");h.validateMovements(e,this.#a,this.defaultAxis);const t=this.#n++;for(this.#r.add(t);this.#r.has(t)&&this.#r.values().next().value!==t;)await this.sleep();return!!this.#r.has(t)&&this.#y(t,e).finally((()=>{this.#r.delete(t)}))}moveBuilder(){return new s(this)}async home(e=.5){const t=this.#b().map((t=>{const s={axis:t.name,to:t.defaultValue};return"boolean"!==t.type&&(s.speed=e),s}));return t.length?this.move(...t):(console.warn("No linear or rotation axes configured."),Promise.resolve(!1))}stop(){this.#h=null,this.#r.clear(),this.#l.forEach((e=>e())),this.#b().forEach((e=>{e.resetOnStop&&(this.$[e.name].value=e.defaultValue)}))}sleep(e){let t;const s=new Promise((e=>{this.#l.add(e),t=e}));return Promise.any([this.#p.sleep(e).then((()=>!0)),s.then((()=>!1))]).finally((()=>{this.#l.delete(t)}))}configureAxis(e){const t=h.validateAxisConfig(e),s=this.#a[e.name];if(s&&(t.value=s.value,t.lastValue=s.lastValue,delete this.#a[s.alias],delete this.$[s.alias]),this.#a[e.name]=t,this.#w(e.name),e.alias){if(this.#a[e.alias])throw new Error(`Alias already refers to another axis: ${e.alias}`);this.#a[e.alias]=t,this.#w(e.alias)}}getAxis(e){const t=this.#a[e];if(t){const e={};return Object.keys(t).forEach((s=>{r(e,s,t[s])})),e}}getAxes(){return this.#b().map((e=>({name:e.name,alias:e.alias,type:e.type,defaultValue:e.defaultValue,max:e.max,min:e.min,value:e.value,lastValue:e.lastValue,resetOnStop:e.resetOnStop})))}updateLimits(e,t,s){const o=e=>!Number.isFinite(e)||e<0||e>1;if(o(t)||o(s)||t===s)throw new Error(`Invalid limits: min = ${t}, max = ${s}`);if(!this.#a[e])throw new Error(`Invalid axis: ${e}`);this.#a[e].min=Math.min(t,s),this.#a[e].max=Math.max(t,s)}addOutputDevice(...e){for(const t of e)if(!(t&&t.write&&t.write instanceof Function))throw new Error(`Invalid device: ${t}`);this.#o.push(...e)}addOutputDevices(...e){this.addOutputDevice(...e)}getOutputDevices(){return[...this.#o]}removeOutputDevice(e){const t=this.#o.indexOf(e);-1!==t&&this.#o.splice(t,1)}stroke(...e){return this.$.stroke(...e).execute()}left(...e){return this.$.left(...e).execute()}forward(...e){return this.$.forward(...e).execute()}twist(...e){return this.$.twist(...e).execute()}roll(...e){return this.$.roll(...e).execute()}pitch(...e){return this.$.pitch(...e).execute()}#w(e){Object.defineProperty(this.$,e,{value:(...t)=>this.moveBuilder()[e](...t),writeable:!1,configurable:!0,enumerable:!0}),Object.defineProperty(this.$[e],"value",{get:()=>this.#a[e].value,set:t=>{const{type:s}=this.#a[e];if("boolean"!==s&&!i(t,0,1))throw new Error(`Invalid value: ${t}`);const o="boolean"===s?!!t:t,a=this.#A(e,o);this.#R(`${a}\n`),this.#a[e].lastValue=this.#a[e].value,this.#a[e].value=o}}),Object.defineProperty(this.$[e],"lastValue",{get:()=>this.#a[e].lastValue}),Object.defineProperty(this.$[e],"defaultValue",{get:()=>this.#a[e].defaultValue}),Object.defineProperty(this.$[e],"min",{get:()=>this.#a[e].min}),Object.defineProperty(this.$[e],"max",{get:()=>this.#a[e].max})}#f(e){this.name=e.name,this.defaultAxis=e.defaultAxis,this.#i=e.frequency||this.#i,e.axes&&e.axes.forEach((e=>{this.configureAxis(e)}))}#R(e){for(const t of this.#o)t.write(e)}async#y(e,t){const s=this.#M(t),{duration:o,stepCount:a}=this.#E(s),i=s.filter((e=>!e.parameters.stepCount)),r=s.filter((e=>!!e.parameters.stepCount));this.#L(i,0);let n=0;const c=this.#p.now();if(a)for(let t=0;t<a;t++){const s=r.filter((e=>t<e.parameters.stepCount));if(this.#L(s,t),n=await this.#$(t,a,o,c,n),!this.#r.has(e))return!1}else await this.sleep(this.#m);return!0}async#$(e,t,s,o,a){if(e===t-1){const e=this.#p.now()-o,t=Math.min(Math.max(s-e,0),this.#m);await this.sleep(t)}else await this.sleep(this.#m-a);return this.#p.now()-o-(e+1)*this.#m}#L(e,t){const s=e.map((e=>this.#P(e,t))).filter((({value:e})=>this.#O(e))),o=s.map((({axis:e,value:t})=>this.#A(e,t)));o.length&&(this.#R(`${o.join(" ")}\n`),s.forEach((({axis:e,value:t})=>{this.#a[e].lastValue=this.#a[e].value,this.#a[e].value=t})))}#P(e,t){const s=t*this.#m,{parameters:i,valueProvider:r}=e,{duration:n}=i,c=r({...i,time:s,index:t,period:this.#m,frequency:this.#i,currentValue:this.#a[i.axis].value,x:Math.min(1,(t+1)/(n*this.#i))}),h=null!=c;return!this.#O(c)&&h&&console.warn(`Invalid value provided: ${c}`),{axis:i.axis,value:Number.isFinite(c)?a(o(c,p.precision),0,1):c}}#O(e){return Number.isFinite(e)||"boolean"==typeof e}#A(e,t){let s;if("boolean"==typeof t)s=t?"9999":"0000";else{const{min:i,max:r}=this.#a[e],n=o(.9999*t,4);s=`${a(o(1e4*((r-i)*n+i)),0,9999)}`.padStart(4,"0")}return`${this.#a[e].name}${s}`}#M(e){const{parameterObjects:t,maxDuration:s}=this.#S(e);return this.#k(t,s),t.map((e=>{const t={};return n(e,"value")?t.valueProvider=e.value:"boolean"===this.#a[e.axis].type?t.valueProvider=()=>e.to:e.to!==e.from?t.valueProvider=this.defaultRamp:t.valueProvider=()=>{},delete e.sync,delete e.value,t.parameters=e,t}))}#S(e){let t=0;const s=e.map((e=>{const s=e.axis||this.defaultAxis,a={...e,axis:s,from:this.#a[s].value,period:this.#m};if(n(e,"to")){const t=e.to-a.from,s=Math.abs(t);n(e,"duration")?a.speed=o(s/e.duration,p.precision):n(e,"speed")&&(a.duration=o(s/a.speed,p.precision)),a.direction=t>0?1:t<0?-1:0}return n(a,"duration")&&(t=Math.max(a.duration,t)),a}));return{maxDuration:t,parameterObjects:s}}#k(e,t){const s=e.reduce(((e,t)=>(e[t.axis]=t,this.#a[t.axis].alias&&(e[this.#a[t.axis].alias]=t),e)),{});e.forEach((e=>{if(n(e,"sync")){let a=e;for(;n(a,"sync");)a=s[a.sync];e.duration=a.duration||t,n(e,"to")&&(e.speed=o(Math.abs(e.to-e.from)/e.duration,p.precision))}else n(e,"duration")||"boolean"===this.#a[e.axis].type||(e.duration=t);n(e,"duration")&&(e.stepCount=Math.ceil(e.duration*this.#i))}))}#E(e){let t=0,s=0;return e.forEach((e=>{const o=e.parameters.stepCount,a=e.parameters.duration;o&&(t=Math.max(o,t)),a&&(s=Math.max(a,s))})),{duration:s,stepCount:t}}#b(){const e={};return Object.values(this.#a).forEach((t=>{e[t.name]=t})),Object.values(e).sort((function(e,t){return e.name>t.name?1:-1}))}static ramp(e){return t=>{const{from:s,to:o}=t;return s+(o-s)*e(t)}}static RAMP_LINEAR(e){return p.ramp((({x:e})=>e))(e)}static RAMP_COS(e){return p.ramp((({x:e})=>-Math.cos(Math.PI*e)/2+.5))(e)}static RAMP_PARABOLIC(e){return p.ramp((({x:e})=>e*e))(e)}static RAMP_NEGATIVE_PARABOLIC(e){return p.ramp((({x:e})=>1-(e-1)**2))(e)}static tempestMotion(e,t,s=0,o=0,a=60,i=0){h.validateTempestParameters(e,t,s,o,a,i);const n=2*Math.PI*a/60,c=.5*(t-e),u=.5*(t+e),p=({index:e,frequency:t})=>{const a=(e+1)*n/t+.5*Math.PI*s+i;return u-c*Math.cos(a+o*Math.sin(a))};return r(p,"from",e),r(p,"to",t),r(p,"phase",s),r(p,"ecc",o),r(p,"bpm",a),p}static blendMotion(e,t,s){return(...a)=>o((1-s)*e(...a)+s*t(...a),p.precision)}static get defaultConfiguration(){return{...u}}static map(e,t,s,o=0,a=1){return(e-t)*(a-o)/(s-t)+o}}const l=p,m=class{#I=[];#j=!1;get complete(){return this.#j}generateActions(e){throw new Error("Behavior does not implement generateActions()")}emitActions(e=1,t=null){for(let s=0;s<e;s++)this.generateActions(t);return this.#I.splice(0,this.#I.length)}async perform(e){if(this.#I.length||this.generateActions(e),!this.#I.length)throw new Error("Behavior did not generate any actions.");const{type:t,value:o}=this.#I.shift();if("function"===t&&o instanceof Function)return o.call(void 0,this,e);if("sleep"===t&&Number.isFinite(o)&&o>=0)return e.sleep(o);if("move"===t&&o instanceof s)return o.execute();if("move"===t&&o instanceof Array)return e.move(...o);throw new Error(`Invalid action: (${t}, ${o})`)}queueMove(...e){const t=e[0]instanceof s?e[0]:e;this.#q({type:"move",value:t})}queueSleep(e){this.#q({type:"sleep",value:e})}queueFunction(e){this.#q({type:"function",value:e})}queueBehavior(e,t=1,s=null){this.#C(e.emitActions(t,s))}queueComplete(){this.queueFunction((()=>{this.#j=!0}))}insertMove(...e){const t=e[0]instanceof s?e[0]:e;this.#F({type:"move",value:t})}insertSleep(e){this.#F({type:"sleep",value:e})}insertFunction(e){this.#F({type:"function",value:e})}insertBehavior(e,t=1,s=null){this.#V(e.emitActions(t,s))}insertComplete(){this.insertFunction((()=>{this.#j=!0}))}#q(e){this.#I.push(e)}#C(e){this.#I.splice(this.#I.length,0,...e)}#F(e){this.#I.unshift(e)}#V(e){this.#I.splice(0,0,...e)}};class f{#T=0;#B;constructor(e){this.#B=e}next(){return this.#B(this.#T++)}get index(){return this.#T}static createFrom(e){return new f(e instanceof Array?t=>e[t%e.length]:"function"!=typeof e?()=>e:e)}}class d extends m{#_;#N;#D;#U;#W;get speed(){return this.#D}get top(){return this.#_}get bottom(){return this.#N}get duration(){return this.#U}static get DEFAULT_CONFIG(){return{top:1,bottom:0,speed:1,shape:l.RAMP_COS,relativeSpeeds:[1,1],suck:null,twist:null,pitch:null}}constructor(e=0,t=1,s=1,o=l.RAMP_COS){let a;super(),a="object"!=typeof e||e instanceof Array?{top:t,bottom:e,speed:s,shape:o}:e,this.#G(a)}generateActions(){this.queueFunction(((e,t)=>{const{value:s,lastValue:o}=t.$.stroke,{target:a,shape:r,direction:n,relativeSpeed:c}=this.#J(s,o),h=this.#D*c,u={to:a,value:r};void 0!==this.#W.speed?(u.speed=h,this.#D=this.#W.speed.next()):(u.duration=this.#U/c,this.#U=this.#W.duration.next());const p=[u];this.#W.twist&&p.push(this.#Z("twist",{direction:n,value:s,target:a,ayva:t,speed:void 0!==this.#W.speed?h:Math.abs(a-s)/u.duration})),this.#W.pitch&&p.push(this.#Z("pitch",{direction:n,value:s,target:a,ayva:t,speed:void 0!==this.#W.speed?h:Math.abs(a-s)/u.duration})),e.insertMove(...p),i(this.#W.suck,0,1)&&(t.$.suck.value=this.#W.suck)}))}#G(e){const t=d.DEFAULT_CONFIG;n(e,"duration")&&delete t.speed;const s={...t,...e};this.#z(s),s.top=f.createFrom(s.top),s.bottom=f.createFrom(s.bottom),s.relativeSpeeds=f.createFrom(s.relativeSpeeds),n(s,"duration")?s.duration=f.createFrom(s.duration):s.speed=f.createFrom(s.speed);const{shape:o}=s;s.shape=new f(o instanceof Array?e=>o[e%o.length]:()=>o),this.#W=s,this.#_=this.#W.top.next(),this.#N=this.#W.bottom.next(),void 0!==this.#W.speed?this.#D=this.#W.speed.next():this.#U=this.#W.duration.next()}#Z(e,{direction:t,value:s,target:o,speed:a,ayva:i}){const{frequency:r}=i,n=("up"===t?0:2)+(this.#W[e].phase||0),c=this.#W[e].ecc||0,h=60*a/(2*Math.abs(s-o)),u=l.tempestMotion(this.#W[e].from,this.#W[e].to,n,c,h),p=u({index:-1,frequency:r});return Math.abs(p-i.$[e].value)>.05?{axis:e,to:l.tempestMotion(this.#W[e].from,this.#W[e].to,n+2,c,h)({index:-1,frequency:r}),value:l.RAMP_COS}:{axis:e,value:u}}#J(e,t){const s=e-t>=0,o=this.#W.shape.index%2==0?"up":"down",a=this.#W.relativeSpeeds.index%2==0?"up":"down";let i,r;return e<=this.#N||e<this.#_&&!s?(r="up",i=this.#_,this.#_=this.#W.top.next(),"down"===o&&this.#W.shape.next(),"down"===a&&this.#W.relativeSpeeds.next()):(r="down",i=this.#N,this.#N=this.#W.bottom.next(),"up"===o&&this.#W.shape.next(),"up"===a&&this.#W.relativeSpeeds.next()),{target:i,shape:this.#W.shape.next(),direction:r,relativeSpeed:this.#W.relativeSpeeds.next()}}#z(e){const t=(e,t)=>{throw new Error(`Invalid stroke ${e}: ${t}`)};if(i(e.bottom,0,1)||"function"==typeof e.bottom||e.bottom instanceof Array||t("bottom",e.bottom),i(e.top,0,1)||"function"==typeof e.top||e.top instanceof Array||t("top",e.top),e.bottom===e.top)throw new Error(`Invalid stroke range specified: (${e.bottom}, ${e.top})`);if(n(e,"speed")&&n(e,"duration"))throw new Error("Cannot specify both a speed and duration");if(!n(e,"speed")||i(e.speed)&&!(e.speed<=0)||"function"==typeof e.speed||e.speed instanceof Array||t("speed",e.speed),!n(e,"duration")||i(e.duration)&&!(e.duration<=0)||"function"==typeof e.duration||e.duration instanceof Array||t("duration",e.duration),"function"==typeof e.shape||e.shape instanceof Array||t("shape",e.shape),!n(e,"relativeSpeeds")||e.relativeSpeeds instanceof Array||t("relative speeds",e.relativeSpeeds),["twist","pitch"].forEach((s=>{"object"!=typeof e[s]&&t(s,e[s]),e[s]&&(i(e[s].from,0,1)||t(`${s} from`,e[s].from),i(e[s].to,0,1)||t(`${s} to`,e[s].to),n(e[s],"phase")&&!i(e[s].phase)&&t(`${s} phase`,e[s].phase))})),e.shape instanceof Array){if(!e.shape.length)throw new Error("Missing stroke shape.");if(e.shape.length%2!=0)throw new Error("Must specify an even number of stroke shapes.");e.shape.forEach((e=>{"function"!=typeof e&&t("shape",e)}))}if(e.relativeSpeeds instanceof Array){if(e.relativeSpeeds.length%2!=0)throw new Error("Must specify an even number of relative speeds.");e.relativeSpeeds.forEach((e=>{(!i(e)||e<=0)&&t("relative speed",e)}))}n(e,"suck")&&!i(e.suck,0,1)&&null!==e.suck&&t("suck",e.suck)}}const v=d,x=[{name:"down-forward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.8,to:.2,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.2,to:.8,phase:1,ecc:.8}},{name:"down-backward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.2,to:.8,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.8,to:.2,phase:1,ecc:.8}},{name:"back-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:1,to:0,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.4,to:1,phase:0,ecc:.5}},{name:"back-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.9,to:.1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward-swirl",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"lean-forward-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"lean-forward-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"diagonal-down-back",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:1,to:.2,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:1,ecc:.6}},{name:"diagonal-down-forward",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:0,to:.8,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:.6}},{name:"orbit-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.9,to:.1,phase:0,ecc:-.3},L2:{from:.1,to:.9,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.1,to:.9,phase:0,ecc:-.3}},{name:"left-right-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:0,to:1,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:1,to:0,phase:1,ecc:0},R2:{from:.5,to:.5,phase:0,ecc:0}},{name:"forward-back-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:0,to:1,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:0}},{name:"vortex-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.6,to:.4,phase:0,ecc:0},L2:{from:.4,to:.6,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.9,to:.1,phase:0,ecc:0}},{name:"swirl-tease",L0:{from:.5,to:1,phase:0,ecc:0},L1:{from:1,to:.3,phase:0,ecc:0},L2:{from:1,to:0,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.4,to:1,phase:0,ecc:0}},{name:"forward-back-grind",L0:{from:0,to:0,phase:0,ecc:0},L1:{from:.3,to:.7,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:.5,ecc:0}},{name:"orbit-grind",L0:{from:0,to:.3,phase:0,ecc:.3},L1:{from:0,to:.6,phase:0,ecc:-.3},L2:{from:.2,to:.8,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.9,to:.1,phase:0,ecc:-.3}}].reduce(((e,t)=>{const{name:s}=t;return delete t.name,e[s]=t,e}),{});class g extends m{#H;#K;#Q;get angle(){return this.#H}set angle(e){this.#H=e}get bpm(){return this.#K}static#X=36;static set granularity(e){if(!i(e,1))throw new Error(`Invalid granularity: ${e}`);g.#X=e}static get granularity(){return g.#X}static get DEFAULT_PARAMETERS(){return{from:0,to:1,phase:0,ecc:0,shift:0}}static get library(){return JSON.parse(JSON.stringify(x))}constructor(e,t=60,s=0){if(super(),"string"==typeof e){if(!n(x,e))throw new Error(`No stroke named ${e} found.`);e=x[e]}r(this,"axes",{}),Object.keys(e).forEach((t=>{r(this.axes,t,{}),Object.keys(e[t]).forEach((s=>{r(this.axes[t],s,e[t][s])})),Object.keys(g.DEFAULT_PARAMETERS).forEach((s=>{n(e[t],s)||r(this.axes[t],s,g.DEFAULT_PARAMETERS[s])}))})),this.#H=s,this.#Q=f.createFrom(t),this.#K=this.#Q.next()}generateActions(){const{granularity:e}=g;for(let t=0;t<e;t++)this.queueFunction((e=>{this.#Y(e,t)}));this.queueFunction((()=>{this.#H+=Math.PI}))}getStartMoves(e,t){const s={};t&&(n(t,"speed")||n(t,"duration"))||(s.speed=1);const o={};return[...Object.keys(this.axes).map((a=>{o[e.getAxis(a).name]=!0;const i=this.axes[a];return{axis:a,to:l.tempestMotion(i.from,i.to,i.phase,i.ecc,this.#K,i.shift+this.#H)({index:-1,frequency:e.frequency}),...s,...t}})),...e.getAxes().filter((e=>!o[e.name])).map((e=>{const o={axis:e.name,to:e.defaultValue,...s,...t};return"boolean"===e.type&&(delete o.speed,delete o.duration),o}))]}createTransition(e,t,s=60){const o=new g(t,s);return o.angle=this.#ee(e,this,o.bpm),{nextStroke:o,transitionStroke:this.#te(o,e)}}#Y(e,t){const{granularity:s}=g,o=Object.keys(this.axes).map((e=>{const o=this.axes[e],a=30/s,i=Math.PI/s;return{axis:e,value:l.tempestMotion(o.from,o.to,o.phase,o.ecc,this.#K,o.shift+this.#H+t*i),duration:a/this.#K}}));e.insertMove(...o),this.#K=this.#Q.next()}#te(e,t){return new y(this,e,t)}#ee(e,t,s){const o=(t.bpm+s)/2;return t.angle+2*Math.PI*(o/60)*e}}class y extends m{#se;#oe;#U;constructor(e,t,s){super(),this.#se=e,this.#oe=t,this.#U=s}generateActions(e){const t={from:.5,to:.5,phase:0,ecc:0},s={from:0,to:0,phase:0,ecc:0},o=this.#ae(this.#se.axes,e),a=this.#ae(this.#oe.axes,e),i={};Object.keys(a).forEach((r=>{const n="auxiliary"===e.getAxis(r).type?s:t,c=o[r]??{...n},h=a[r];i[r]=this.#ie(c,h)})),Object.keys(o).forEach((a=>{if(!i[a]){const r="auxiliary"===e.getAxis(a).type?s:t,n=o[a],c={...r};i[a]=this.#ie(n,c)}}));const r=[];Object.keys(i).forEach((e=>{r.push({axis:e,...i[e]})})),this.queueMove(...r),this.queueComplete()}#ie(e,t){const s=this.#se.bpm,o=(this.#se.bpm+this.#oe.bpm)/2;return{value:a=>{const{x:i}=a,r=l.map(i,0,1,e.from,t.from),n=l.map(i,0,1,e.to,t.to),c=l.map(i,0,1,e.phase,t.phase),h=l.map(i,0,1,e.ecc,t.ecc),u=l.map(i,0,1,s,o);return l.tempestMotion(r,n,c,h,u,this.#se.angle)(a)},duration:this.#U}}#ae(e,t){return Object.keys(e).reduce(((s,o)=>(s[t.getAxis(o).name]=e[o],s)),{})}}const b=g,w=class{#re;#ne;constructor(e,t){if(i(e,0)&&void 0===t)this.#ne=1e3*e;else{if(!(i(e,0)&&i(t,0)&&e<t))throw new Error(`Invalid duration range: (${e}, ${t})`);this.#ne=1e3*(Math.random()*(t-e)+e)}this.#re=performance.now()}get targetElapsed(){return this.#ne}get complete(){return performance.now()-this.#re>=this.#ne}get percentage(){return a((performance.now()-this.#re)/this.#ne,0,1)}},A=class{connected=!1;_baudRate;_output=null;_input=null;_serial=null;constructor(e=115200,t=null){this._baudRate=e,this._serial=t||(globalThis.navigator?globalThis.navigator.serial:null)}async requestConnection(){const e=await this._serial.requestPort();await e.open({baudRate:this._baudRate});const t=new TextEncoderStream;t.readable.pipeTo(e.writable);const s=new TextDecoderStream;e.readable.pipeTo(s.writable),this._output=t.writable.getWriter(),this._input=s.readable.getReader(),this.connected=!0;const o=t=>{t.target===e&&(this.connected=!1,this._serial.removeEventListener("disconnect",o))};return this._serial.addEventListener("disconnect",o),new Promise((e=>{setTimeout(e,2e3)}))}write(e){if(!this.connected)throw new Error("No device connected.");this._output.write(e)}};var R=t.UE,M=t.fV,E=t.ft,L=t.ni,$=t._I,P=t.ZP;export{R as AyvaBehavior,M as ClassicStroke,E as TempestStroke,L as VariableDuration,$ as WebSerialDevice,P as default};