var e={d:(t,s)=>{for(var o in s)e.o(s,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:s[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{UE:()=>m,fV:()=>v,ft:()=>b,ni:()=>w,_I:()=>A,ZP:()=>l});const s=class{#e;#t=[];constructor(e){this.#e=e,Object.values(e.axes).forEach((e=>{this[e.name]=this.#s(e.name),e.alias&&(this[e.alias]=this.#s(e.alias))}))}execute(){return this.#e.move(...this.#t)}#s(e){return(...t)=>{if(3===t.length&&"number"==typeof t[0]&&"number"==typeof t[1]&&"function"==typeof t[2])this.#t.push({axis:e,to:t[0],speed:t[1],value:t[2]});else if(2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,to:t[0],speed:t[1]});else if(2===t.length&&"number"==typeof t[0]&&"function"==typeof t[1])this.#t.push({axis:e,to:t[0],value:t[1]});else if(1===t.length&&"number"==typeof t[0])this.#t.push({axis:e,to:t[0]});else if(2===t.length&&"function"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,value:t[0],duration:t[1]});else if(1===t.length&&"function"==typeof t[0])this.#t.push({axis:e,value:t[0]});else{if(1!==t.length||"object"!=typeof t[0])throw new Error(`Invalid arguments: ${t}`);this.#t.push({...t[0],axis:e})}return this}}};function o(e,t=0){const s=10**t;return Math.round(s*e)/s}function i(e,t,s){return Math.max(t,Math.min(s,e))}function r(e,t,s){return!(!Number.isFinite(e)||void 0!==t&&e<t||void 0!==s&&e>s)}function a(e,t,s){Object.defineProperty(e,t,{value:s,writeable:!1,configurable:!1,enumerable:!0})}function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function c(e){throw new Error(e)}const h={validateMovements(e,t,s){const o={};let i=!1,r=!1;e&&e.length||c("Must supply at least one movement."),e.forEach((e=>{e&&"object"==typeof e||c(`Invalid movement: ${e}`);const a=t=>c(`Invalid value for parameter '${t}': ${e[t]}`),h=n(e,"to"),u=n(e,"speed"),p=n(e,"duration"),l=n(e,"value"),m=e.axis||s;if(m||c("No default axis configured. Must specify an axis for each movement."),n(e,"axis")&&("string"==typeof e.axis&&e.axis.trim()&&t[e.axis]||a("axis")),h){let s=!1;s="boolean"===t[m].type?"boolean"!=typeof e.to:!Number.isFinite(e.to)||e.to<0||e.to>1,s&&a("to")}else l||c("Must provide a 'to' property or 'value' function.");u&&p&&c("Cannot supply both speed and duration."),(u||p)&&(i=!0,u&&(!Number.isFinite(e.speed)||e.speed<=0)?a("speed"):p&&(!Number.isFinite(e.duration)||e.duration<=0)&&a("duration")),u&&!h&&c("Must provide a target position when specifying speed."),l&&"function"!=typeof e.value&&c("'value' must be a function."),n(e,"sync")&&("string"==typeof e.sync&&e.sync.trim()||a("sync"),(n(e,"speed")||n(e,"duration"))&&c(`Cannot specify a speed or duration when sync property is present: ${e.axis}`)),"boolean"!==t[m].type?r=!0:(n(e,"speed")&&c(`Cannot specify speed for boolean axes: ${m}`),n(e,"duration")&&h&&!l&&c("Cannot specify a duration for a boolean axis movement with constant value.")),o[m]&&c(`Duplicate axis movement: ${m}`),o[m]=e,t[m].alias&&(o[t[m].alias]=e)})),e.forEach((e=>{let t=e;const s=e.axis;for(;n(t,"sync");)o[t.sync]||c(`Cannot sync with axis not specified in movement: ${t.axis} -> ${t.sync}`),t=o[t.sync],t.sync===s&&c("Sync axes cannot form a cycle.")})),!i&&r&&c("At least one movement must have a speed or duration.")},validateAxisConfig(e){e&&"object"==typeof e||c(`Invalid configuration object: ${e}`);const t={name:"string",type:"string",alias:"string",max:"number",min:"number"},s=["name","type"].filter((t=>void 0===e[t]||null===e[t])).sort();s.length&&c(`Configuration is missing properties: ${s.join(", ")}`);const o=[];let i;Object.keys(t).forEach((s=>{const i=e[s];null!=i&&(typeof i!==t[s]?o.push(s):"min"!==s&&"max"!==s||(!Number.isFinite(i)||i<0||i>1)&&o.push(s))})),o.length&&c(`Invalid configuration parameter(s): ${o.sort().map((t=>`${t} = ${e[t]}`)).join(", ")}`),-1===["linear","rotation","auxiliary","boolean"].indexOf(e.type)&&c(`Invalid type. Must be linear, rotation, auxiliary, or boolean: ${e.type}`),i="boolean"!==e.type&&("auxiliary"===e.type?0:.5);const r={...e,max:e.max||1,min:e.min||0,value:i,lastValue:i};return(r.max===r.min||r.min>r.max)&&c(`Invalid configuration parameter(s): max = ${r.max}, min = ${r.min}`),r},validateTempestParameters(e,t,s,o,i,a){if(!(r(e,0,1)&&r(t,0,1)&&r(s)&&r(o)&&r(i)&&i>0&&r(a)))throw new Error(`One or more stroke parameters are invalid (${e}, ${t}, ${s}, ${o}, ${i}, ${a})`)}},u={name:"SR6",defaultAxis:"L0",axes:[{name:"L0",type:"linear",alias:"stroke"},{name:"L1",type:"linear",alias:"forward"},{name:"L2",type:"linear",alias:"left"},{name:"R0",type:"rotation",alias:"twist"},{name:"R1",type:"rotation",alias:"roll"},{name:"R2",type:"rotation",alias:"pitch"},{name:"A0",alias:"valve",type:"auxiliary"},{name:"A1",alias:"suck",type:"auxiliary"},{name:"A2",alias:"lube",type:"auxiliary"},{name:"V0",alias:"vibe0",type:"auxiliary"},{name:"V1",alias:"vibe1",type:"auxiliary"}]};class p{#o=[];#i={};#r=50;#a=new Set;#n=1;#c=1;#h=null;#u=!1;#p;#l=new Set;defaultRamp=p.RAMP_COS;static get precision(){return 10}get performing(){return this.#u}get axes(){const e={};return Object.keys(this.#i).forEach((t=>{e[t]=this.getAxis(t)})),e}get frequency(){return this.#r}get period(){return this.#m}get#m(){return 1/this.#r}constructor(e){a(this,"$",{}),e&&this.#f(e),"undefined"==typeof Worker?this.#p={sleep:e=>new Promise((t=>{setTimeout(t,1e3*e)})),now:()=>performance.now()/1e3}:this.#p=new class{#d;#v={};#x=1;constructor(){this.#d=new Worker(this.#g((function(){onmessage=function(e){const{id:t,delay:s}=e.data;setTimeout((()=>{postMessage(t)}),1e3*s)}}))),this.#d.onmessage=({data:e})=>{const t=e;this.#v[t](),delete this.#v[t]}}sleep(e){return new Promise((t=>{const s=this.#x++;this.#v[s]=t,this.#d.postMessage({id:s,delay:e})}))}now(){return performance.now()/1e3}#g(e){const t=new Blob([`(${e.toString()})()`],{type:"text/javascript"});return URL.createObjectURL(t)}}}defaultConfiguration(){return this.#f(u),this}getTimer(){return this.#p}async do(e){this.stop();const t=this.#c++;for(this.#h=t;this.#u;)await this.sleep();for(this.#u=!0;this.#h===t&&!e.complete;)try{await e.perform(this)}catch(e){console.error(`Error performing behavior: ${e}`);break}return this.#u=!1,this.#h===t&&(this.#h=null,!0)}async move(...e){if(!this.#o||!this.#o.length)throw new Error("No output devices have been added.");h.validateMovements(e,this.#i,this.defaultAxis);const t=this.#n++;for(this.#a.add(t);this.#a.has(t)&&this.#a.values().next().value!==t;)await this.sleep();return!!this.#a.has(t)&&this.#y(t,e).finally((()=>{this.#a.delete(t)}))}moveBuilder(){return new s(this)}async home(e=.5,t=.5){const s=this.#b().filter((e=>"linear"===e.type||"rotation"===e.type)).map((s=>({to:e,speed:t,axis:s.name})));return s.length?this.move(...s):(console.warn("No linear or rotation axes configured."),Promise.resolve(!1))}stop(){this.#h=null,this.#a.clear(),this.#l.forEach((e=>e()))}sleep(e){let t;const s=new Promise((e=>{this.#l.add(e),t=e}));return Promise.any([this.#p.sleep(e).then((()=>!0)),s.then((()=>!1))]).finally((()=>{this.#l.delete(t)}))}configureAxis(e){const t=h.validateAxisConfig(e),s=this.#i[e.name];if(s&&(t.value=s.value,t.lastValue=s.lastValue,delete this.#i[s.alias],delete this.$[s.alias]),this.#i[e.name]=t,this.#w(e.name),e.alias){if(this.#i[e.alias])throw new Error(`Alias already refers to another axis: ${e.alias}`);this.#i[e.alias]=t,this.#w(e.alias)}}getAxis(e){const t=this.#i[e];if(t){const e={};return Object.keys(t).forEach((s=>{a(e,s,t[s])})),e}}updateLimits(e,t,s){const o=e=>!Number.isFinite(e)||e<0||e>1;if(o(t)||o(s)||t===s)throw new Error(`Invalid limits: min = ${t}, max = ${s}`);if(!this.#i[e])throw new Error(`Invalid axis: ${e}`);this.#i[e].min=Math.min(t,s),this.#i[e].max=Math.max(t,s)}addOutputDevice(...e){for(const t of e)if(!(t&&t.write&&t.write instanceof Function))throw new Error(`Invalid device: ${t}`);this.#o.push(...e)}addOutputDevices(...e){this.addOutputDevice(...e)}getOutputDevices(){return[...this.#o]}removeOutputDevice(e){const t=this.#o.indexOf(e);-1!==t&&this.#o.splice(t,1)}stroke(...e){return this.$.stroke(...e).execute()}left(...e){return this.$.left(...e).execute()}forward(...e){return this.$.forward(...e).execute()}twist(...e){return this.$.twist(...e).execute()}roll(...e){return this.$.roll(...e).execute()}pitch(...e){return this.$.pitch(...e).execute()}#w(e){Object.defineProperty(this.$,e,{value:(...t)=>this.moveBuilder()[e](...t),writeable:!1,configurable:!0,enumerable:!0}),Object.defineProperty(this.$[e],"value",{get:()=>this.#i[e].value,set:t=>{const{type:s}=this.#i[e];if("boolean"!==s&&!r(t,0,1))throw new Error(`Invalid value: ${t}`);const o="boolean"===s?!!t:t,i=this.#A(e,o);this.#R(`${i}\n`),this.#i[e].lastValue=this.#i[e].value,this.#i[e].value=o}}),Object.defineProperty(this.$[e],"lastValue",{get:()=>this.#i[e].lastValue}),Object.defineProperty(this.$[e],"min",{get:()=>this.#i[e].min}),Object.defineProperty(this.$[e],"max",{get:()=>this.#i[e].max})}#f(e){this.name=e.name,this.defaultAxis=e.defaultAxis,this.#r=e.frequency||this.#r,e.axes&&e.axes.forEach((e=>{this.configureAxis(e)}))}#R(e){for(const t of this.#o)t.write(e)}async#y(e,t){const s=this.#M(t),{duration:o,stepCount:i}=this.#E(s),r=s.filter((e=>!e.parameters.stepCount)),a=s.filter((e=>!!e.parameters.stepCount));this.#L(r,0);let n=0;const c=this.#p.now();if(i)for(let t=0;t<i;t++){const s=a.filter((e=>t<e.parameters.stepCount));if(this.#L(s,t),n=await this.#$(t,i,o,c,n),!this.#a.has(e))return!1}else await this.sleep(this.#m);return!0}async#$(e,t,s,o,i){if(e===t-1){const e=this.#p.now()-o,t=Math.min(Math.max(s-e,0),this.#m);await this.sleep(t)}else await this.sleep(this.#m-i);return this.#p.now()-o-(e+1)*this.#m}#L(e,t){const s=e.map((e=>this.#P(e,t))).filter((({value:e})=>this.#S(e))),o=s.map((({axis:e,value:t})=>this.#A(e,t)));o.length&&(this.#R(`${o.join(" ")}\n`),s.forEach((({axis:e,value:t})=>{this.#i[e].lastValue=this.#i[e].value,this.#i[e].value=t})))}#P(e,t){const s=t*this.#m,{parameters:r,valueProvider:a}=e,{duration:n}=r,c=a({...r,time:s,index:t,period:this.#m,frequency:this.#r,currentValue:this.#i[r.axis].value,x:Math.min(1,(t+1)/(n*this.#r))}),h=null!=c;return!this.#S(c)&&h&&console.warn(`Invalid value provided: ${c}`),{axis:r.axis,value:Number.isFinite(c)?i(o(c,p.precision),0,1):c}}#S(e){return Number.isFinite(e)||"boolean"==typeof e}#A(e,t){let s;if("boolean"==typeof t)s=t?"9999":"0000";else{const{min:r,max:a}=this.#i[e],n=o(.9999*t,4);s=`${i(o(1e4*((a-r)*n+r)),0,9999)}`.padStart(4,"0")}return`${this.#i[e].name}${s}`}#M(e){const{parameterObjects:t,maxDuration:s}=this.#k(e);return this.#O(t,s),t.map((e=>{const t={};return n(e,"value")?t.valueProvider=e.value:"boolean"===this.#i[e.axis].type?t.valueProvider=()=>e.to:e.to!==e.from?t.valueProvider=this.defaultRamp:t.valueProvider=()=>{},delete e.sync,delete e.value,t.parameters=e,t}))}#k(e){let t=0;const s=e.map((e=>{const s=e.axis||this.defaultAxis,i={...e,axis:s,from:this.#i[s].value,period:this.#m};if(n(e,"to")){const t=e.to-i.from,s=Math.abs(t);n(e,"duration")?i.speed=o(s/e.duration,p.precision):n(e,"speed")&&(i.duration=o(s/i.speed,p.precision)),i.direction=t>0?1:t<0?-1:0}return n(i,"duration")&&(t=Math.max(i.duration,t)),i}));return{maxDuration:t,parameterObjects:s}}#O(e,t){const s=e.reduce(((e,t)=>(e[t.axis]=t,this.#i[t.axis].alias&&(e[this.#i[t.axis].alias]=t),e)),{});e.forEach((e=>{if(n(e,"sync")){let i=e;for(;n(i,"sync");)i=s[i.sync];e.duration=i.duration||t,n(e,"to")&&(e.speed=o(Math.abs(e.to-e.from)/e.duration,p.precision))}else n(e,"duration")||"boolean"===this.#i[e.axis].type||(e.duration=t);n(e,"duration")&&(e.stepCount=Math.ceil(e.duration*this.#r))}))}#E(e){let t=0,s=0;return e.forEach((e=>{const o=e.parameters.stepCount,i=e.parameters.duration;o&&(t=Math.max(o,t)),i&&(s=Math.max(i,s))})),{duration:s,stepCount:t}}#b(){const e={};return Object.values(this.#i).forEach((t=>{e[t.name]=t})),Object.values(e).sort((function(e,t){return e.name>t.name?1:-1}))}static ramp(e){return t=>{const{from:s,to:o}=t;return s+(o-s)*e(t)}}static RAMP_LINEAR(e){return p.ramp((({x:e})=>e))(e)}static RAMP_COS(e){return p.ramp((({x:e})=>-Math.cos(Math.PI*e)/2+.5))(e)}static RAMP_PARABOLIC(e){return p.ramp((({x:e})=>e*e))(e)}static RAMP_NEGATIVE_PARABOLIC(e){return p.ramp((({x:e})=>1-(e-1)**2))(e)}static tempestMotion(e,t,s=0,o=0,i=60,r=0){h.validateTempestParameters(e,t,s,o,i,r);const n=2*Math.PI*i/60,c=.5*(t-e),u=.5*(t+e),p=({index:e,frequency:t})=>{const i=(e+1)*n/t+.5*Math.PI*s+r;return u-c*Math.cos(i+o*Math.sin(i))};return a(p,"from",e),a(p,"to",t),a(p,"phase",s),a(p,"ecc",o),a(p,"bpm",i),p}static blendMotion(e,t,s){return(...i)=>o((1-s)*e(...i)+s*t(...i),p.precision)}static get defaultConfiguration(){return{...u}}static map(e,t,s,o=0,i=1){return(e-t)*(i-o)/(s-t)+o}}const l=p,m=class{#I=[];#j=!1;get complete(){return this.#j}generateActions(e){throw new Error("Behavior does not implement generateActions()")}emitActions(e=1,t=null){for(let s=0;s<e;s++)this.generateActions(t);return this.#I.splice(0,this.#I.length)}async perform(e){if(this.#I.length||this.generateActions(e),!this.#I.length)throw new Error("Behavior did not generate any actions.");const{type:t,value:o}=this.#I.shift();if("function"===t&&o instanceof Function)return o.call(void 0,this,e);if("sleep"===t&&Number.isFinite(o)&&o>=0)return e.sleep(o);if("move"===t&&o instanceof s)return o.execute();if("move"===t&&o instanceof Array)return e.move(...o);throw new Error(`Invalid action: (${t}, ${o})`)}queueMove(...e){const t=e[0]instanceof s?e[0]:e;this.#q({type:"move",value:t})}queueSleep(e){this.#q({type:"sleep",value:e})}queueFunction(e){this.#q({type:"function",value:e})}queueBehavior(e,t=1,s=null){this.#C(e.emitActions(t,s))}queueComplete(){this.queueFunction((()=>{this.#j=!0}))}insertMove(...e){const t=e[0]instanceof s?e[0]:e;this.#F({type:"move",value:t})}insertSleep(e){this.#F({type:"sleep",value:e})}insertFunction(e){this.#F({type:"function",value:e})}insertBehavior(e,t=1,s=null){this.#T(e.emitActions(t,s))}insertComplete(){this.insertFunction((()=>{this.#j=!0}))}#q(e){this.#I.push(e)}#C(e){this.#I.splice(this.#I.length,0,...e)}#F(e){this.#I.unshift(e)}#T(e){this.#I.splice(0,0,...e)}};class f{#B=0;#_;constructor(e){this.#_=e}next(){return this.#_(this.#B++)}get index(){return this.#B}static createFrom(e){return new f(e instanceof Array?t=>e[t%e.length]:"function"!=typeof e?()=>e:e)}}class d extends m{#N;#V;#D;#U;#W;get speed(){return this.#D}get top(){return this.#N}get bottom(){return this.#V}get duration(){return this.#U}static get DEFAULT_CONFIG(){return{top:1,bottom:0,speed:1,shape:l.RAMP_COS,relativeSpeeds:[1,1],suck:null,twist:null,pitch:null}}constructor(e=0,t=1,s=1,o=l.RAMP_COS){let i;super(),i="object"!=typeof e||e instanceof Array?{top:t,bottom:e,speed:s,shape:o}:e,this.#G(i)}generateActions(){this.queueFunction(((e,t)=>{const{value:s,lastValue:o}=t.$.stroke,{target:i,shape:a,direction:n,relativeSpeed:c}=this.#J(s,o),h=this.#D*c,u={to:i,value:a};void 0!==this.#W.speed?(u.speed=h,this.#D=this.#W.speed.next()):(u.duration=this.#U/c,this.#U=this.#W.duration.next());const p=[u];this.#W.twist&&p.push(this.#Z("twist",{direction:n,value:s,target:i,ayva:t,speed:void 0!==this.#W.speed?h:Math.abs(i-s)/u.duration})),this.#W.pitch&&p.push(this.#Z("pitch",{direction:n,value:s,target:i,ayva:t,speed:void 0!==this.#W.speed?h:Math.abs(i-s)/u.duration})),e.insertMove(...p),r(this.#W.suck,0,1)&&(t.$.suck.value=this.#W.suck)}))}#G(e){const t=d.DEFAULT_CONFIG;n(e,"duration")&&delete t.speed;const s={...t,...e};this.#z(s),s.top=f.createFrom(s.top),s.bottom=f.createFrom(s.bottom),s.relativeSpeeds=f.createFrom(s.relativeSpeeds),n(s,"duration")?s.duration=f.createFrom(s.duration):s.speed=f.createFrom(s.speed);const{shape:o}=s;s.shape=new f(o instanceof Array?e=>o[e%o.length]:()=>o),this.#W=s,this.#N=this.#W.top.next(),this.#V=this.#W.bottom.next(),void 0!==this.#W.speed?this.#D=this.#W.speed.next():this.#U=this.#W.duration.next()}#Z(e,{direction:t,value:s,target:o,speed:i,ayva:r}){const{frequency:a}=r,n=("up"===t?0:2)+(this.#W[e].phase||0),c=this.#W[e].ecc||0,h=60*i/(2*Math.abs(s-o)),u=l.tempestMotion(this.#W[e].from,this.#W[e].to,n,c,h),p=u({index:-1,frequency:a});return Math.abs(p-r.$[e].value)>.05?{axis:e,to:l.tempestMotion(this.#W[e].from,this.#W[e].to,n+2,c,h)({index:-1,frequency:a}),value:l.RAMP_COS}:{axis:e,value:u}}#J(e,t){const s=e-t>=0,o=this.#W.shape.index%2==0?"up":"down",i=this.#W.relativeSpeeds.index%2==0?"up":"down";let r,a;return e<=this.#V||e<this.#N&&!s?(a="up",r=this.#N,this.#N=this.#W.top.next(),"down"===o&&this.#W.shape.next(),"down"===i&&this.#W.relativeSpeeds.next()):(a="down",r=this.#V,this.#V=this.#W.bottom.next(),"up"===o&&this.#W.shape.next(),"up"===i&&this.#W.relativeSpeeds.next()),{target:r,shape:this.#W.shape.next(),direction:a,relativeSpeed:this.#W.relativeSpeeds.next()}}#z(e){const t=(e,t)=>{throw new Error(`Invalid stroke ${e}: ${t}`)};if(r(e.bottom,0,1)||"function"==typeof e.bottom||e.bottom instanceof Array||t("bottom",e.bottom),r(e.top,0,1)||"function"==typeof e.top||e.top instanceof Array||t("top",e.top),e.bottom===e.top)throw new Error(`Invalid stroke range specified: (${e.bottom}, ${e.top})`);if(n(e,"speed")&&n(e,"duration"))throw new Error("Cannot specify both a speed and duration");if(!n(e,"speed")||r(e.speed)&&!(e.speed<=0)||"function"==typeof e.speed||e.speed instanceof Array||t("speed",e.speed),!n(e,"duration")||r(e.duration)&&!(e.duration<=0)||"function"==typeof e.duration||e.duration instanceof Array||t("duration",e.duration),"function"==typeof e.shape||e.shape instanceof Array||t("shape",e.shape),!n(e,"relativeSpeeds")||e.relativeSpeeds instanceof Array||t("relative speeds",e.relativeSpeeds),["twist","pitch"].forEach((s=>{"object"!=typeof e[s]&&t(s,e[s]),e[s]&&(r(e[s].from,0,1)||t(`${s} from`,e[s].from),r(e[s].to,0,1)||t(`${s} to`,e[s].to),n(e[s],"phase")&&!r(e[s].phase)&&t(`${s} phase`,e[s].phase))})),e.shape instanceof Array){if(!e.shape.length)throw new Error("Missing stroke shape.");if(e.shape.length%2!=0)throw new Error("Must specify an even number of stroke shapes.");e.shape.forEach((e=>{"function"!=typeof e&&t("shape",e)}))}if(e.relativeSpeeds instanceof Array){if(e.relativeSpeeds.length%2!=0)throw new Error("Must specify an even number of relative speeds.");e.relativeSpeeds.forEach((e=>{(!r(e)||e<=0)&&t("relative speed",e)}))}n(e,"suck")&&!r(e.suck,0,1)&&null!==e.suck&&t("suck",e.suck)}}const v=d,x=[{name:"down-forward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.8,to:.2,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.2,to:.8,phase:1,ecc:.8}},{name:"down-backward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.2,to:.8,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.8,to:.2,phase:1,ecc:.8}},{name:"back-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:1,to:0,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.4,to:1,phase:0,ecc:.5}},{name:"back-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.9,to:.1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward-swirl",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"lean-forward-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"lean-forward-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"diagonal-down-back",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:1,to:.2,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:1,ecc:.6}},{name:"diagonal-down-forward",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:0,to:.8,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:.6}},{name:"orbit-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.9,to:.1,phase:0,ecc:-.3},L2:{from:.1,to:.9,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.1,to:.9,phase:0,ecc:-.3}},{name:"left-right-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:0,to:1,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:1,to:0,phase:1,ecc:0},R2:{from:.5,to:.5,phase:0,ecc:0}},{name:"forward-back-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:0,to:1,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:0}},{name:"vortex-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.6,to:.4,phase:0,ecc:0},L2:{from:.4,to:.6,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.9,to:.1,phase:0,ecc:0}},{name:"swirl-tease",L0:{from:.5,to:1,phase:0,ecc:0},L1:{from:1,to:.3,phase:0,ecc:0},L2:{from:1,to:0,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.4,to:1,phase:0,ecc:0}},{name:"forward-back-grind",L0:{from:0,to:0,phase:0,ecc:0},L1:{from:.3,to:.7,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:.5,ecc:0}},{name:"orbit-grind",L0:{from:0,to:.3,phase:0,ecc:.3},L1:{from:0,to:.6,phase:0,ecc:-.3},L2:{from:.2,to:.8,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.9,to:.1,phase:0,ecc:-.3}}].reduce(((e,t)=>{const{name:s}=t;return delete t.name,e[s]=t,e}),{});class g extends m{#H;#K;#Q;get angle(){return this.#H}set angle(e){this.#H=e}get bpm(){return this.#K}static#X=36;static set granularity(e){if(!r(e,1))throw new Error(`Invalid granularity: ${e}`);g.#X=e}static get granularity(){return g.#X}static get DEFAULT_PARAMETERS(){return{from:0,to:1,phase:0,ecc:0,shift:0}}static get library(){return JSON.parse(JSON.stringify(x))}constructor(e,t=60,s=0){if(super(),"string"==typeof e){if(!n(x,e))throw new Error(`No stroke named ${e} found.`);e=x[e]}a(this,"axes",{}),Object.keys(e).forEach((t=>{a(this.axes,t,{}),Object.keys(e[t]).forEach((s=>{a(this.axes[t],s,e[t][s])})),Object.keys(g.DEFAULT_PARAMETERS).forEach((s=>{n(e[t],s)||a(this.axes[t],s,g.DEFAULT_PARAMETERS[s])}))})),this.#H=s,this.#Q=f.createFrom(t),this.#K=this.#Q.next()}generateActions(){const{granularity:e}=g;for(let t=0;t<e;t++)this.queueFunction((e=>{this.#Y(e,t)}));this.queueFunction((()=>{this.#H+=Math.PI}))}getTransitionMoves(e,t){return this.getStartMoves(e,t)}getStartMoves(e,t){const s={};return t&&(n(t,"speed")||n(t,"duration"))||(s.speed=1),Object.keys(this.axes).map((o=>{const i=this.axes[o];return{axis:o,to:l.tempestMotion(i.from,i.to,i.phase,i.ecc,this.#K,i.shift+this.#H)({index:-1,frequency:e.frequency}),...s,...t}}))}createTransition(e,t,s=60){const o=new g(t,s);return o.angle=this.#ee(e,this,o.bpm),{nextStroke:o,transitionStroke:this.#te(o,e)}}#Y(e,t){const{granularity:s}=g,o=Object.keys(this.axes).map((e=>{const o=this.axes[e],i=30/s,r=Math.PI/s;return{axis:e,value:l.tempestMotion(o.from,o.to,o.phase,o.ecc,this.#K,o.shift+this.#H+t*r),duration:i/this.#K}}));e.insertMove(...o),this.#K=this.#Q.next()}#te(e,t){return new y(this,e,t)}#ee(e,t,s){const o=(t.bpm+s)/2;return t.angle+2*Math.PI*(o/60)*e}}class y extends m{#se;#oe;#U;constructor(e,t,s){super(),this.#se=e,this.#oe=t,this.#U=s}generateActions(e){const t={from:.5,to:.5,phase:0,ecc:0},s={from:0,to:0,phase:0,ecc:0},o=this.#ie(this.#se.axes,e),i=this.#ie(this.#oe.axes,e),r={};Object.keys(i).forEach((a=>{const n="auxiliary"===e.getAxis(a).type?s:t,c=o[a]??{...n},h=i[a];r[a]=this.#re(c,h)})),Object.keys(o).forEach((i=>{if(!r[i]){const a="auxiliary"===e.getAxis(i).type?s:t,n=o[i],c={...a};r[i]=this.#re(n,c)}}));const a=[];Object.keys(r).forEach((e=>{a.push({axis:e,...r[e]})})),this.queueMove(...a),this.queueComplete()}#re(e,t){const s=this.#se.bpm,o=(this.#se.bpm+this.#oe.bpm)/2;return{value:i=>{const{x:r}=i,a=l.map(r,0,1,e.from,t.from),n=l.map(r,0,1,e.to,t.to),c=l.map(r,0,1,e.phase,t.phase),h=l.map(r,0,1,e.ecc,t.ecc),u=l.map(r,0,1,s,o);return l.tempestMotion(a,n,c,h,u,this.#se.angle)(i)},duration:this.#U}}#ie(e,t){return Object.keys(e).reduce(((s,o)=>(s[t.getAxis(o).name]=e[o],s)),{})}}const b=g,w=class{#ae;#ne;constructor(e,t){if(r(e,0)&&void 0===t)this.#ne=1e3*e;else{if(!(r(e,0)&&r(t,0)&&e<t))throw new Error(`Invalid duration range: (${e}, ${t})`);this.#ne=1e3*(Math.random()*(t-e)+e)}this.#ae=performance.now()}get targetElapsed(){return this.#ne}get complete(){return performance.now()-this.#ae>=this.#ne}get percentage(){return i((performance.now()-this.#ae)/this.#ne,0,1)}},A=class{connected=!1;_baudRate;_output=null;_input=null;_serial=null;constructor(e=115200,t=null){this._baudRate=e,this._serial=t||(globalThis.navigator?globalThis.navigator.serial:null)}async requestConnection(){const e=await this._serial.requestPort();await e.open({baudRate:this._baudRate});const t=new TextEncoderStream;t.readable.pipeTo(e.writable);const s=new TextDecoderStream;e.readable.pipeTo(s.writable),this._output=t.writable.getWriter(),this._input=s.readable.getReader(),this.connected=!0;const o=t=>{t.target===e&&(this.connected=!1,this._serial.removeEventListener("disconnect",o))};return this._serial.addEventListener("disconnect",o),new Promise((e=>{setTimeout(e,2e3)}))}write(e){if(!this.connected)throw new Error("No device connected.");this._output.write(e)}};var R=t.UE,M=t.fV,E=t.ft,L=t.ni,$=t._I,P=t.ZP;export{R as AyvaBehavior,M as ClassicStroke,E as TempestStroke,L as VariableDuration,$ as WebSerialDevice,P as default};