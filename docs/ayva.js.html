

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> ayva.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Ayva Documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-getting-started.html">
                                Getting Started
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-motion-api.html">
                                Motion API
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-configuration.html">
                                Configuration
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Ayva.html">Ayva</a></li></ul><h3>Global</h3><ul><li><a href="global.html#OSR2_CONFIG">OSR2_CONFIG</a></li><li><a href="global.html#SR6_CONFIG">SR6_CONFIG</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>ayva.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
  clamp, round, has, fail, createConstantProperty
} from './util.js';

import { SR6_CONFIG } from './ayva-configs.js';

class Ayva {
  #devices = [];

  #axes = {};

  #frequency = 50; // Hz

  #movements = new Set();

  #nextMovementId = 1;

  get axes () {
    return { ...this.#axes };
  }

  get frequency () {
    return this.#frequency;
  }

  get period () {
    return this.#period;
  }

  get #period () {
    return 1 / this.#frequency;
  }

  /**
   * Create a new instance of Ayva with the specified configuration.
   *
   * @param {Object} [config]
   * @param {String} [config.name] - the name of this configuration
   * @param {String} [config.defaultAxis] - the default axis to command when no axis is specified
   * @param {Object[]} [config.axes] - an array of axis configurations (see {@link Ayva#configureAxis})
   * @class Ayva
   */
  constructor (config) {
    if (config) {
      this.#configure(config);
    }
  }

  /**
   * Setup this Ayva instance with the default configuration (a six axis stroker).
   *
   * @example
   * const ayva = new Ayva().defaultConfiguration();
   *
   * @returns the instance of Ayva
   */
  defaultConfiguration () {
    this.#configure(SR6_CONFIG);
    return this;
  }

  /**
   * Performs movements along one or more axes. This is a powerful method that can synchronize
   * axis movement while allowing for fine control over position, speed, or move duration.
   * For full details on how to use this method, see the {@tutorial motion-api} tutorial.
   *
   * @example
   * ayva.move({
   *   axis: 'stroke',
   *   to: 0,
   *   speed: 1,
   * },{
   *   axis: 'twist',
   *   to: 0.5,
   *   duration: 1,
   * },{
   *   axis: 'roll',
   *   value: ({ x }) => Math.sin(x * Math.PI),
   * });
   *
   * @param  {Object} movements
   * @return {Promise} a promise that resolves with the boolean value true when all movements have finished, or false if the move is cancelled.
   */
  async move (...movements) {
    if (!this.#devices || !this.#devices.length) {
      throw new Error('No output devices have been added.');
    }

    this.#validateMovements(movements);

    const movementId = this.#nextMovementId++;
    this.#movements.add(movementId);

    while (this.#movements.has(movementId) &amp;&amp; this.#movements.values().next().value !== movementId) {
      // Wait until current movements have completed to proceed.
      await this.sleep(); // eslint-disable-line no-await-in-loop
    }

    if (!this.#movements.has(movementId)) {
      // This move must have been cancelled.
      return false;
    }

    try {
      return await this.#performMovements(movementId, movements);
    } catch (error) {
      return Promise.reject(error);
    } finally {
      this.#movements.delete(movementId);
    }
  }

  /**
   * Moves all linear and rotation axes to their neutral positions.
   *
   * @param {Number} [to = 0.5] - optional target position to home to.
   * @param {Number} [speed = 0.5] - optional speed of the movement.
   * @return {Promise} A promise that resolves when the movements are finished.
   */
  async home (to = 0.5, speed = 0.5) {
    const movements = this.#getAxesArray()
      .filter((axis) => axis.type === 'linear' || axis.type === 'rotation')
      .map((axis) => ({ to, speed, axis: axis.name }));

    if (movements.length) {
      return this.move(...movements);
    }

    console.warn('No linear or rotation axes configured.'); // eslint-disable-line no-console
    return Promise.resolve();
  }

  /**
   * Cancels all running or pending movements immediately.
   */
  stop () {
    this.#movements.clear();
  }

  /**
   * Asynchronously sleep for the specified number of seconds.
   *
   * TODO: Externalize this into a timer that can be swapped out.
   *
   * @param {*} seconds
   * @returns {Promise} a Promise that resolves when the number of seconds have passed.
   */
  async sleep (seconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, seconds * 1000);
    });
  }

  /**
   * Configures a new axis. If an axis with the same name has already been configured, it will be overridden.
   *
   * @example
   * const ayva = new Ayva();
   *
   * ayva.configureAxis({
   *   name: 'L0',
   *   type: 'linear',
   *   alias: 'stroke',
   *   max: 0.9,
   *   min: 0.3,
   * });
   *
   * @param {Object} axisConfig - axis configuration object
   * @param {String} axisConfig.name - the machine name of this axis (such as L0, R0, etc...)
   * @param {String} axisConfig.type - linear, rotation, auxiliary, or boolean
   * @param {String|String[]} [axisConfig.alias] - an alias used to refer to this axis
   * @param {Object} [axisConfig.max = 1] - specifies maximum value for this axis (not applicable for boolean axes)
   * @param {Number} [axisConfig.min = 0] - specifies minimum value for this axis (not applicable for boolean axes)
   */
  configureAxis (axisConfig) {
    const resultConfig = this.#validateAxisConfig(axisConfig);

    const oldConfig = this.#axes[axisConfig.name];

    if (oldConfig) {
      resultConfig.value = oldConfig.value;
      delete this.#axes[oldConfig.alias];
    }

    this.#axes[axisConfig.name] = resultConfig;

    if (axisConfig.alias) {
      if (this.#axes[axisConfig.alias]) {
        throw new Error(`Alias already refers to another axis: ${axisConfig.alias}`);
      }

      this.#axes[axisConfig.alias] = resultConfig;
    }
  }

  /**
   * Fetch an immutable object containing the properties for an axis.
   *
   * @param {String} name - the name or alias of the axis to get.
   * @return {Object} axisConfig - an immutable object of axis properties.
   */
  getAxis (name) {
    const fetchedAxis = this.#axes[name];

    if (fetchedAxis) {
      const axis = {};

      Object.keys(fetchedAxis).forEach((key) => {
        createConstantProperty(axis, key, fetchedAxis[key]);
      });

      return axis;
    }

    return undefined;
  }

  /**
   * Update the limits for the specified axis.
   *
   * @param {String} axis
   * @param {Number} from - value between 0 and 1
   * @param {Number} to - value between 0 and 1
   */
  updateLimits (axis, from, to) {
    const isInvalid = (value) => !Number.isFinite(value) || value &lt; 0 || value > 1;

    if (isInvalid(from) || isInvalid(to) || from === to) {
      throw new Error(`Invalid limits: min = ${from}, max = ${to}`);
    }

    if (!this.#axes[axis]) {
      throw new Error(`Invalid axis: ${axis}`);
    }

    this.#axes[axis].min = Math.min(from, to);
    this.#axes[axis].max = Math.max(from, to);
  }

  /**
   * Registers a new output device. Ayva outputs commands to all connected devices.
   * More than one device can be specified.
   *
   * @param {...Object} device - object with a write method.
   */
  addOutputDevice (...devices) {
    for (const device of devices) {
      if (!(device &amp;&amp; device.write &amp;&amp; device.write instanceof Function)) {
        throw new Error(`Invalid device: ${device}`);
      }
    }

    this.#devices.push(...devices);
  }

  /**
   * Alias for #addOutputDevice()
   *
   * @ignore
   * @param {...Object} device - object with a write method.
   */
  addOutputDevices (...devices) {
    this.addOutputDevice(...devices);
  }

  /**
   * Setup the configuration.
   */
  #configure (config) {
    this.name = config.name;
    this.defaultAxis = config.defaultAxis;
    this.#frequency = (config.frequency || this.#frequency);

    if (config.axes) {
      config.axes.forEach((axis) => {
        this.configureAxis(axis);
      });
    }
  }

  /**
   * Writes the specified command out to all connected devices.
   */
  #write (command) {
    for (const device of this.#devices) {
      device.write(command);
    }
  }

  async #performMovements (movementId, movements) {
    const allProviders = this.#createValueProviders(movements);
    const stepCount = this.#computeStepCount(allProviders);
    const immediateProviders = allProviders.filter((provider) => !provider.parameters.stepCount);
    const stepProviders = allProviders.filter((provider) => !!provider.parameters.stepCount);

    this.#executeProviders(immediateProviders, 0);

    for (let index = 0; index &lt; stepCount; index++) {
      const unfinishedProviders = stepProviders.filter((provider) => index &lt; provider.parameters.stepCount);
      this.#executeProviders(unfinishedProviders, index);

      await this.sleep(this.#period); // eslint-disable-line no-await-in-loop

      if (!this.#movements.has(movementId)) {
        // This move was cancelled.
        return false;
      }
    }

    return true;
  }

  #executeProviders (providers, index) {
    const axisValues = providers
      .map((provider) => this.#executeProvider(provider, index))
      .filter(({ value }) => this.#isValidAxisValue(value));

    const tcodes = axisValues.map(({ axis, value }) => this.#tcode(axis, value));

    if (tcodes.length) {
      this.#write(`${tcodes.join(' ')}\n`);

      axisValues.forEach(({ axis, value }) => {
        this.#axes[axis].value = value;
      });
    }
  }

  #executeProvider (provider, index) {
    const time = index * this.#period;
    const { parameters, valueProvider } = provider;
    const { stepCount } = parameters;

    const nextValue = valueProvider({
      ...parameters,
      time,
      index,
      period: this.#period,
      frequency: this.#frequency,
      currentValue: this.#axes[parameters.axis].value,
      x: stepCount === 0 ? 1 : (index + 1) / stepCount,
    });

    const notNullOrUndefined = nextValue !== null &amp;&amp; nextValue !== undefined; // Allow null or undefined to indicate no movement.

    if (!this.#isValidAxisValue(nextValue) &amp;&amp; notNullOrUndefined) {
      console.warn(`Invalid value provided: ${nextValue}`); // eslint-disable-line no-console
    }

    return {
      axis: parameters.axis,
      value: Number.isFinite(nextValue) ? clamp(round(nextValue, 10), 0, 1) : nextValue,
    };
  }

  #isValidAxisValue (value) {
    return Number.isFinite(value) || typeof value === 'boolean';
  }

  /**
   * Converts the value into a standard live command TCode string for the specified axis. (i.e. 0.5 -> L0500)
   * If the axis is a boolean axis, true values get mapped to 999 and false gets mapped to 000.
   *
   * @param {String} axis
   * @param {Number} value
   * @returns {String} the TCode string
   */
  #tcode (axis, value) {
    let valueText;

    if (typeof value === 'boolean') {
      valueText = value ? '9999' : '0000';
    } else {
      const { min, max } = this.#axes[axis];
      const normalizedValue = round(value * 0.9999, 4); // Convert values from range (0, 1) to (0, 0.9999)
      const scaledValue = (max - min) * normalizedValue + min;

      valueText = `${clamp(round(scaledValue * 10000), 0, 9999)}`.padStart(4, '0');
    }

    return `${this.#axes[axis].name}${valueText}`;
  }

  /**
   * Create value providers with initial parameters.
   *
   * Precondition: Each movement is a valid movement per the Motion API.
   * @param {Object[]} movements
   * @returns {Object[]} - array of value providers with parameters.
   */
  #createValueProviders (movements) {
    let maxDuration = 0;

    const computedMovements = movements.map((movement) => {
      // Initialize all parameters that we can deduce.
      const axis = movement.axis || this.defaultAxis;

      const result = {
        ...movement,
        axis,
        from: this.#axes[axis].value,
        period: this.#period,
      };

      if (has(movement, 'to')) {
        const distance = movement.to - result.from;
        const absoluteDistance = Math.abs(distance);

        if (has(movement, 'duration')) {
          // { to: &lt;number>, duration: &lt;number> }
          result.speed = round(absoluteDistance / movement.duration, 10);
        } else if (has(movement, 'speed')) {
          // { to: &lt;number>, speed: &lt;number> }
          result.duration = round(absoluteDistance / movement.speed, 10);
        }

        result.direction = distance > 0 ? 1 : distance &lt; 0 ? -1 : 0; // eslint-disable-line no-nested-ternary
      }

      if (has(result, 'duration')) {
        maxDuration = Math.max(result.duration, maxDuration);
      }

      return result;
    });

    const movementsByAxis = computedMovements.reduce((map, p) => {
      map[p.axis] = p;

      if (this.#axes[p.axis].alias) {
        map[this.#axes[p.axis].alias] = p;
      }

      return map;
    }, {});

    computedMovements.forEach((movement) => {
      // We need to compute the duration for any movements we couldn't in the first pass.
      // This will be either implicit or explicit sync movements.
      if (has(movement, 'sync')) {
        // Excplicit sync.
        let syncMovement = movement;

        while (has(syncMovement, 'sync')) {
          syncMovement = movementsByAxis[syncMovement.sync];
        }

        movement.duration = syncMovement.duration || maxDuration;

        if (has(movement, 'to')) {
          // Now we can compute a speed.
          movement.speed = round(Math.abs(movement.to - movement.from) / movement.duration, 10);
        }
      } else if (!has(movement, 'duration') &amp;&amp; this.#axes[movement.axis].type !== 'boolean') {
        // Implicit sync to max duration.
        movement.duration = maxDuration;
      }

      if (has(movement, 'duration')) {
        movement.stepCount = round(movement.duration * this.#frequency);
      } else if (this.#axes[movement.axis].type !== 'boolean') {
        // By this point, the only movements without a duration should be boolean.
        // This should literally never happen because of validation. But including here for debugging and clarity.
        fail(`Unable to compute duration for movement along axis: ${movement.axis}`);
      }
    });

    // Create the actual value providers.
    return computedMovements.map((movement) => {
      const provider = {};

      if (!has(movement, 'value')) {
        // Create a value provider from parameters.
        if (this.#axes[movement.axis].type === 'boolean') {
          provider.valueProvider = () => movement.to;
        } else if (movement.to !== movement.from) {
          // TODO: Allow for a default ramp function.
          provider.valueProvider = Ayva.RAMP_LINEAR;
        } else {
          // No movement.
          provider.valueProvider = () => {};
        }
      } else {
        // User provided value provider.
        provider.valueProvider = movement.value;
      }

      delete movement.sync;
      delete movement.value;
      provider.parameters = movement;

      return provider;
    });
  }

  /**
   * Compute the total steps of the move given a list of value providers.
   * i.e. The maximum number of steps.
   *
   * @param {Object[]} valueProviders
   */
  #computeStepCount (valueProviders) {
    let maxStepCount = 0;

    valueProviders.forEach((provider) => {
      const steps = provider.parameters.stepCount;

      if (steps) {
        maxStepCount = Math.max(steps, maxStepCount);
      }
    });

    return maxStepCount;
  }

  /**
   * All the validation on movement descriptors :O
   *
   * @param {Array} movements
   */
  #validateMovements (movements) {
    const movementMap = {};
    let atLeastOneDuration = false;
    let atLeastOneNonBoolean = false;

    if (!movements || !movements.length) {
      fail('Must supply at least one movement.');
    }

    movements.forEach((movement) => {
      if (!movement || typeof movement !== 'object') {
        fail(`Invalid movement: ${movement}`);
      }

      const invalidValue = (name) => fail(`Invalid value for parameter '${name}': ${movement[name]}`);
      const hasTo = has(movement, 'to');
      const hasSpeed = has(movement, 'speed');
      const hasDuration = has(movement, 'duration');
      const hasValue = has(movement, 'value');
      const axis = movement.axis || this.defaultAxis;

      if (!axis) {
        fail('No default axis configured. Must specify an axis for each movement.');
      }

      if (has(movement, 'axis')) {
        if (typeof movement.axis !== 'string' || !movement.axis.trim() || !this.#axes[movement.axis]) {
          invalidValue('axis');
        }
      }

      if (hasTo) {
        let invalidTo = false;

        if (this.#axes[axis].type === 'boolean') {
          invalidTo = typeof movement.to !== 'boolean';
        } else {
          invalidTo = !Number.isFinite(movement.to) || (movement.to &lt; 0 || movement.to > 1);
        }

        if (invalidTo) {
          invalidValue('to');
        }
      } else if (!hasValue) {
        fail('Must provide a \'to\' property or \'value\' function.');
      }

      if (hasSpeed &amp;&amp; hasDuration) {
        fail('Cannot supply both speed and duration.');
      }

      if (hasSpeed || hasDuration) {
        atLeastOneDuration = true;

        if (hasSpeed &amp;&amp; (!Number.isFinite(movement.speed) || movement.speed &lt;= 0)) {
          invalidValue('speed');
        } else if (hasDuration &amp;&amp; (!Number.isFinite(movement.duration) || movement.duration &lt;= 0)) {
          invalidValue('duration');
        }
      }

      if (hasSpeed &amp;&amp; !hasTo) {
        fail('Must provide a target position when specifying speed.');
      }

      if (hasValue &amp;&amp; typeof movement.value !== 'function') {
        fail('\'value\' must be a function.');
      }

      if (has(movement, 'sync')) {
        if (typeof movement.sync !== 'string' || !movement.sync.trim()) {
          invalidValue('sync');
        }

        if (has(movement, 'speed') || has(movement, 'duration')) {
          fail(`Cannot specify a speed or duration when sync property is present: ${movement.axis}`);
        }
      }

      if (this.#axes[axis].type !== 'boolean') {
        atLeastOneNonBoolean = true;
      } else {
        if (has(movement, 'speed')) {
          fail(`Cannot specify speed for boolean axes: ${axis}`);
        }

        if (has(movement, 'duration') &amp;&amp; hasTo &amp;&amp; !hasValue) {
          // { to: &lt;boolean>, duration: &lt;number> } is invalid (for now).
          fail('Cannot specify a duration for a boolean axis movement with constant value.');
        }
      }

      if (movementMap[axis]) {
        fail(`Duplicate axis movement: ${axis}`);
      }

      movementMap[axis] = movement;

      if (this.#axes[axis].alias) {
        movementMap[this.#axes[axis].alias] = movement;
      }
    });

    movements.forEach((movement) => {
      let syncMovement = movement;
      const originalMovementAxis = movement.axis;

      while (has(syncMovement, 'sync')) {
        if (!movementMap[syncMovement.sync]) {
          fail(`Cannot sync with axis not specified in movement: ${syncMovement.axis} -> ${syncMovement.sync}`);
        }

        syncMovement = movementMap[syncMovement.sync];

        if (syncMovement.sync === originalMovementAxis) {
          fail('Sync axes cannot form a cycle.');
        }
      }
    });

    if (!atLeastOneDuration &amp;&amp; atLeastOneNonBoolean) {
      fail('At least one movement must have a speed or duration.');
    }
  }

  /**
   * Ensure all required fields are present in the configuration and that all are of valid types.
   *
   * @param {Object} axisConfig
   */
  #validateAxisConfig (axisConfig) {
    if (!axisConfig || typeof axisConfig !== 'object') {
      fail(`Invalid configuration object: ${axisConfig}`);
    }

    const required = ['name', 'type'];

    const types = {
      name: 'string',
      type: 'string',
      alias: 'string',
      max: 'number',
      min: 'number',
    };

    const missing = required.filter(
      (property) => axisConfig[property] === undefined || axisConfig[property] === null
    ).sort();

    if (missing.length) {
      fail(`Configuration is missing properties: ${missing.join(', ')}`);
    }

    const invalid = [];

    Object.keys(types).forEach((property) => {
      const value = axisConfig[property];

      // Since we've already caught missing required fields by this point,
      // we only need to check types of optional fields if they are actually present.
      if (value !== undefined &amp;&amp; value !== null) {
        // eslint-disable-next-line valid-typeof
        if (typeof value !== types[property]) {
          invalid.push(property);
        } else if (property === 'min' || property === 'max') {
          if (!Number.isFinite(value) || value &lt; 0 || value > 1) {
            invalid.push(property);
          }
        }
      }
    });

    if (invalid.length) {
      const message = invalid.sort().map((property) => `${property} = ${axisConfig[property]}`).join(', ');
      fail(`Invalid configuration parameter(s): ${message}`);
    }

    if (['linear', 'rotation', 'auxiliary', 'boolean'].indexOf(axisConfig.type) === -1) {
      fail(`Invalid type. Must be linear, rotation, auxiliary, or boolean: ${axisConfig.type}`);
    }

    const resultConfig = {
      ...axisConfig,
      max: axisConfig.max || 1,
      min: axisConfig.min || 0,
      value: axisConfig.type === 'boolean' ? false : 0.5, // Default value. 0.5 is home position for linear, rotation, and auxiliary.
    };

    if (resultConfig.max === resultConfig.min || resultConfig.min > resultConfig.max) {
      fail(`Invalid configuration parameter(s): max = ${resultConfig.max}, min = ${resultConfig.min}`);
    }

    return resultConfig;
  }

  #getAxesArray () {
    const uniqueAxes = {};

    Object.values(this.#axes).forEach((axis) => {
      uniqueAxes[axis.name] = axis;
    });

    function sortByName (a, b) {
      return a.name > b.name ? 1 : -1;
    }

    return Object.values(uniqueAxes).sort(sortByName);
  }

  /**
   * Value provider that generates motion towards a target position with constant velocity.
   */
  static get RAMP_LINEAR () {
    return ({ to, from, x }) => from + ((to - from) * x);
  }

  /**
   * Value provider that generates mmotion towards a target position that resembles a negative cos wave (0 - 180 degrees)
   */
  static get RAMP_NEGATIVE_COS () {
    return ({ to, from, x }) => {
      const value = (-Math.cos(Math.PI * x) / 2) + 0.5;

      return from + ((to - from) * value);
    };
  }

  /**
   * Value provider that generates motion towards a target position in the shape of half a parabola.
   */
  static get RAMP_PARABOLIC () {
    return ({ to, from, x }) => ((to - from) * x * x) + from;
  }

  /**
   * Value provider that generates motion towards a target position in the shape of an upside down half of parabola.
   */
  static get RAMP_NEGATIVE_PARABOLIC () {
    return ({ to, from, x }) => {
      const value = -((x - 1) ** 2) + 1;

      return ((to - from) * value) + from;
    };
  }
}

// Separate default export from the class declaration because of jsdoc shenanigans...
export default Ayva;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
